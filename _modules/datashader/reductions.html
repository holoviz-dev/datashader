
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>datashader.reductions â€” Datashader v0.16.1a1</title>
<script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
<!-- Loaded before other Sphinx assets -->
<link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet"/>
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet"/>
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet"/>
<link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" rel="preload" type="font/woff2"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/graphviz.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/copybutton.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/nbsite.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/notebook.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/gallery.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/alert.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/dataframe.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/scroller.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/css/custom.css" rel="stylesheet" type="text/css"/>
<!-- Pre-loaded scripts that we'll load fully later -->
<link as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" rel="preload"/>
<link as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" rel="preload"/>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
<script src="../../_static/jquery.js"></script>
<script src="../../_static/underscore.js"></script>
<script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
<script src="../../_static/doctools.js"></script>
<script src="../../_static/sphinx_highlight.js"></script>
<script src="../../_static/clipboard.min.js"></script>
<script src="../../_static/copybutton.js"></script>
<script src="../../_static/design-tabs.js"></script>
<script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-M7369XC3Y3"></script>
<script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-M7369XC3Y3');
            </script>
<script>DOCUMENTATION_OPTIONS.pagename = '_modules/datashader/reductions';</script>
<link href="../../_static/favicon.ico" rel="shortcut icon"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="en" name="docsearch:language"/>
</head>
<body data-bs-root-margin="0px 0px -60%" data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-default-mode="" data-offset="180">
<a class="skip-link" href="#main-content">Skip to main content</a>
<input class="sidebar-toggle" id="__primary" name="__primary" type="checkbox"/>
<label class="overlay overlay-primary" for="__primary"></label>
<input class="sidebar-toggle" id="__secondary" name="__secondary" type="checkbox"/>
<label class="overlay overlay-secondary" for="__secondary"></label>
<div class="search-button__wrapper">
<div class="search-button__overlay"></div>
<div class="search-button__search-container">
<form action="../../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="fa-solid fa-magnifying-glass"></i>
<input aria-label="Search the docs ..." autocapitalize="off" autocomplete="off" autocorrect="off" class="form-control" id="search-input" name="q" placeholder="Search the docs ..." spellcheck="false" type="search"/>
<span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
</div>
<nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
<label class="sidebar-toggle primary-toggle" for="__primary">
<span class="fa-solid fa-bars"></span>
</label>
<div class="navbar-header-items__start">
<div class="navbar-item">
<a class="navbar-brand logo" href="../../index.html">
<img alt="Logo image" class="logo__image only-light" src="../../_static/logo_horizontal.svg"/>
<script>document.write(`<img src="../../_static/logo_horizontal.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
</a></div>
</div>
<div class="col-lg-9 navbar-header-items">
<div class="me-auto navbar-header-items__center">
<div class="navbar-item"><nav class="navbar-nav">
<p aria-label="Site Navigation" aria-level="1" class="sidebar-header-items__title" role="heading">
    Site Navigation
  </p>
<ul class="bd-navbar-elements navbar-nav">
<li class="nav-item">
<a class="nav-link nav-internal" href="../../index.html">
                        Introduction
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../getting_started/index.html">
                        Getting Started
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../user_guide/index.html">
                        User Guide
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../topics/index.html">
                        Topics
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../releases.html">
                        Releases
                      </a>
</li>
<div class="nav-item dropdown">
<button aria-expanded="false" aria-haspopup="true" class="btn dropdown-toggle nav-item" data-bs-toggle="dropdown" type="button">
                    More
                </button>
<div class="dropdown-menu">
<li class="nav-item">
<a class="nav-link nav-internal" href="../../api.html">
                        API
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../FAQ.html">
                        FAQ
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../about.html">
                        About
                      </a>
</li>
</div>
</div>
</ul>
</nav></div>
</div>
<div class="navbar-header-items__end">
<div class="navbar-item navbar-persistent--container">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
</div>
<div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
<div class="navbar-item"><ul aria-label="Icon Links" class="navbar-icon-links navbar-nav">
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://github.com/holoviz/datashader" rel="noopener" target="_blank" title="GitHub"><span><i class="fa-brands fa-square-github"></i></span>
<label class="sr-only">GitHub</label></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://twitter.com/datashader" rel="noopener" target="_blank" title="Twitter"><span><i class="fa-brands fa-twitter-square"></i></span>
<label class="sr-only">Twitter</label></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://discourse.holoviz.org/c/datashader/" rel="noopener" target="_blank" title="Discourse"><span><i class="fa-brands fa-discourse"></i></span>
<label class="sr-only">Discourse</label></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://holoviz.org/" rel="noopener" target="_blank" title="HoloViz"><img alt="HoloViz" class="icon-link-image" src="../../_static/holoviz-icon-white.svg"/></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://discord.gg/AXRHnJU6sP" rel="noopener" target="_blank" title="Discord"><span><i class="fa-brands fa-discord"></i></span>
<label class="sr-only">Discord</label></a>
</li>
</ul></div>
</div>
</div>
<div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
</div>
</div>
</nav>
<div class="bd-container">
<div class="bd-container__inner bd-page-width">
<div class="bd-sidebar-primary bd-sidebar">
<div class="sidebar-header-items sidebar-primary__section">
<div class="sidebar-header-items__center">
<div class="navbar-item"><nav class="navbar-nav">
<p aria-label="Site Navigation" aria-level="1" class="sidebar-header-items__title" role="heading">
    Site Navigation
  </p>
<ul class="bd-navbar-elements navbar-nav">
<li class="nav-item">
<a class="nav-link nav-internal" href="../../index.html">
                        Introduction
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../getting_started/index.html">
                        Getting Started
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../user_guide/index.html">
                        User Guide
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../topics/index.html">
                        Topics
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../releases.html">
                        Releases
                      </a>
</li>
<div class="nav-item dropdown">
<button aria-expanded="false" aria-haspopup="true" class="btn dropdown-toggle nav-item" data-bs-toggle="dropdown" type="button">
                    More
                </button>
<div class="dropdown-menu">
<li class="nav-item">
<a class="nav-link nav-internal" href="../../api.html">
                        API
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../FAQ.html">
                        FAQ
                      </a>
</li>
<li class="nav-item">
<a class="nav-link nav-internal" href="../../about.html">
                        About
                      </a>
</li>
</div>
</div>
</ul>
</nav></div>
</div>
<div class="sidebar-header-items__end">
<div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
<div class="navbar-item"><ul aria-label="Icon Links" class="navbar-icon-links navbar-nav">
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://github.com/holoviz/datashader" rel="noopener" target="_blank" title="GitHub"><span><i class="fa-brands fa-square-github"></i></span>
<label class="sr-only">GitHub</label></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://twitter.com/datashader" rel="noopener" target="_blank" title="Twitter"><span><i class="fa-brands fa-twitter-square"></i></span>
<label class="sr-only">Twitter</label></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://discourse.holoviz.org/c/datashader/" rel="noopener" target="_blank" title="Discourse"><span><i class="fa-brands fa-discourse"></i></span>
<label class="sr-only">Discourse</label></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://holoviz.org/" rel="noopener" target="_blank" title="HoloViz"><img alt="HoloViz" class="icon-link-image" src="../../_static/holoviz-icon-white.svg"/></a>
</li>
<li class="nav-item">
<a class="nav-link" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://discord.gg/AXRHnJU6sP" rel="noopener" target="_blank" title="Discord"><span><i class="fa-brands fa-discord"></i></span>
<label class="sr-only">Discord</label></a>
</li>
</ul></div>
</div>
</div>
<div class="sidebar-primary-items__start sidebar-primary__section">
<div class="sidebar-primary-item"><nav aria-label="Section Navigation" class="bd-docs-nav bd-links">
<div class="bd-toc-item navbar-nav"><ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Introduction</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../getting_started/index.html">Getting Started</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../user_guide/index.html">User Guide</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Plotting_Pitfalls.html">Plotting Pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Points.html">Points</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Timeseries.html">Timeseries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Trajectories.html">Trajectories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Grids.html">Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Trimesh.html">Trimesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Networks.html">Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Polygons.html">Polygons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Extending.html">Extending</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Performance.html">Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Geography.html">Geography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Inspection_Reductions.html">Inspection Reductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../user_guide/Geopandas.html">GeoPandas</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../topics/index.html">Topics</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/census/census.html">Census</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/gerrymandering/gerrymandering.html">Gerrymandering</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/landsat/landsat.html">Landsat</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/network_packets/network_packets.html">Network Packets</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/nyc_taxi/nyc_taxi-nongeo.html">NYC Taxi</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/opensky/opensky.html">OpenSky</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/osm/osm-1billion.html">OSM 1 Billion</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/osm/osm-3billion.html">OSM</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/datashader_dashboard/dashboard.html">Dashboard</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/attractors/attractors.html">Strange attractors</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/bay_trimesh/bay_trimesh.html">Bay Trimesh</a></li>
<li class="toctree-l2"><a class="reference external" href="https://anaconda.org/defusco/amz_centers/notebook">Amazon.com center distance</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.pyviz.org/uk_researchers/uk_researchers.html">UK Researchers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
</ul>
</div>
</nav></div>
</div>
<div class="sidebar-primary-items__end sidebar-primary__section">
</div>
<div id="rtd-footer-container"></div>
</div>
<main class="bd-main" id="main-content">
<div class="bd-content">
<div class="bd-article-container">
<div class="bd-header-article">
<div class="header-article-items header-article__inner">
<div class="header-article-items__start">
<div class="header-article-item">
<nav aria-label="Breadcrumbs">
<ul aria-label="Breadcrumb" class="bd-breadcrumbs" role="navigation">
<li class="breadcrumb-item breadcrumb-home">
<a aria-label="Home" class="nav-link" href="../../index.html">
<i class="fa-solid fa-home"></i>
</a>
</li>
<li class="breadcrumb-item"><a class="nav-link" href="../index.html">Module code</a></li>
<li aria-current="page" class="breadcrumb-item active">datashader.reductions</li>
</ul>
</nav>
</div>
</div>
</div>
</div>
<div id="searchbox"></div>
<article class="bd-article" role="main">
<h1>Source code for datashader.reductions</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">packaging.version</span> <span class="kn">import</span> <span class="n">Version</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">datashader.datashape</span> <span class="kn">import</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">isnumeric</span><span class="p">,</span> <span class="n">Record</span><span class="p">,</span> <span class="n">Option</span>
<span class="kn">from</span> <span class="nn">datashader.datashape</span> <span class="kn">import</span> <span class="n">coretypes</span> <span class="k">as</span> <span class="n">ct</span>
<span class="kn">from</span> <span class="nn">toolz</span> <span class="kn">import</span> <span class="n">concat</span><span class="p">,</span> <span class="n">unique</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

<span class="kn">from</span> <span class="nn">datashader.antialias</span> <span class="kn">import</span> <span class="n">AntialiasCombination</span><span class="p">,</span> <span class="n">AntialiasStage2</span>
<span class="kn">from</span> <span class="nn">datashader.utils</span> <span class="kn">import</span> <span class="n">isminus1</span><span class="p">,</span> <span class="n">isnull</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span> <span class="k">as</span> <span class="n">nb_cuda</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">datashader.transfer_functions._cuda_utils</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">cuda_atomic_nanmin</span><span class="p">,</span> <span class="n">cuda_atomic_nanmax</span><span class="p">,</span> <span class="n">cuda_args</span><span class="p">,</span> <span class="n">cuda_row_min_in_place</span><span class="p">,</span>
        <span class="n">cuda_nanmax_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_nanmax_n_in_place_3d</span><span class="p">,</span>
        <span class="n">cuda_nanmin_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_nanmin_n_in_place_3d</span><span class="p">,</span>
        <span class="n">cuda_row_max_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_row_max_n_in_place_3d</span><span class="p">,</span>
        <span class="n">cuda_row_min_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_row_min_n_in_place_3d</span><span class="p">,</span> <span class="n">cuda_shift_and_insert</span><span class="p">,</span>
    <span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="p">(</span><span class="n">cuda_atomic_nanmin</span><span class="p">,</span> <span class="n">cuda_atomic_nanmax</span><span class="p">,</span> <span class="n">cuda_args</span><span class="p">,</span> <span class="n">cuda_row_min_in_place</span><span class="p">,</span>
        <span class="n">cuda_nanmax_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_nanmax_n_in_place_3d</span><span class="p">,</span>
        <span class="n">cuda_nanmin_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_nanmin_n_in_place_3d</span><span class="p">,</span>
        <span class="n">cuda_row_max_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_row_max_n_in_place_3d</span><span class="p">,</span>
        <span class="n">cuda_row_min_n_in_place_4d</span><span class="p">,</span> <span class="n">cuda_row_min_n_in_place_3d</span><span class="p">,</span> <span class="n">cuda_shift_and_insert</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cudf</span>
    <span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="n">cudf</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">=</span> <span class="kc">None</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Expr</span><span class="p">,</span> <span class="n">ngjit</span><span class="p">,</span> <span class="n">nansum_missing</span><span class="p">,</span> <span class="n">nanmax_in_place</span><span class="p">,</span> <span class="n">nansum_in_place</span><span class="p">,</span> <span class="n">row_min_in_place</span><span class="p">,</span>
    <span class="n">nanmax_n_in_place_4d</span><span class="p">,</span> <span class="n">nanmax_n_in_place_3d</span><span class="p">,</span> <span class="n">nanmin_n_in_place_4d</span><span class="p">,</span> <span class="n">nanmin_n_in_place_3d</span><span class="p">,</span>
    <span class="n">row_max_n_in_place_4d</span><span class="p">,</span> <span class="n">row_max_n_in_place_3d</span><span class="p">,</span> <span class="n">row_min_n_in_place_4d</span><span class="p">,</span> <span class="n">row_min_n_in_place_3d</span><span class="p">,</span>
    <span class="n">shift_and_insert</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">SpecialColumn</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Internally datashader identifies the columns required by the user's</span>
<span class="sd">    Reductions and extracts them from the supplied source (e.g. DataFrame) to</span>
<span class="sd">    pass through the dynamically-generated append function in compiler.py and</span>
<span class="sd">    end up as arguments to the Reduction._append* functions. Each column is</span>
<span class="sd">    a string name or a SpecialColumn. A column of None is used in Reduction</span>
<span class="sd">    classes to denote that no column is required.</span>
<span class="sd">    """</span>
    <span class="n">RowIndex</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">class</span> <span class="nc">UsesCudaMutex</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Enum that encapsulates the need for a Reduction to use a CUDA mutex to</span>
<span class="sd">    operate correctly on a GPU. Possible values:</span>

<span class="sd">    No: the Reduction append_cuda function is atomic and no mutex is required.</span>
<span class="sd">    Local: Reduction append_cuda needs wrapping in a mutex.</span>
<span class="sd">    Global: the overall compiled append function needs wrapping in a mutex.</span>
<span class="sd">    """</span>
    <span class="n">No</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Local</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Global</span> <span class="o">=</span> <span class="mi">2</span>


<span class="k">class</span> <span class="nc">Preprocess</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Base clase for preprocessing steps."""</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">SpecialColumn</span> <span class="o">|</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nan_check_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">extract</span><span class="p">(</span><span class="n">Preprocess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Extract a column from a dataframe as a numpy array of values."""</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
            <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">"_datashader_row_offset"</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                <span class="n">row_offset</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">attr_name</span><span class="p">]</span>
                <span class="n">row_length</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">"_datashader_row_length"</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s2">"attrs"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">row_offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">attrs</span> <span class="ow">or</span> <span class="n">df</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">row_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cudf</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">row_offset</span><span class="p">,</span> <span class="n">row_offset</span> <span class="o">+</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'f'</span><span class="p">:</span>
                <span class="n">nullval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nullval</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">Version</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Version</span><span class="p">(</span><span class="s2">"22.02"</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">to_cupy</span><span class="p">(</span><span class="n">na_value</span><span class="o">=</span><span class="n">nullval</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">to_gpu_array</span><span class="p">(</span><span class="n">fillna</span><span class="o">=</span><span class="n">nullval</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">row_offset</span><span class="p">,</span> <span class="n">row_offset</span> <span class="o">+</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">row_offset</span><span class="p">,</span> <span class="n">row_offset</span> <span class="o">+</span> <span class="n">row_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cuda</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>


<span class="k">class</span> <span class="nc">CategoryPreprocess</span><span class="p">(</span><span class="n">Preprocess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Base class for categorizing preprocessors."""</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cat_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns name of categorized column"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>

    <span class="k">def</span> <span class="nf">categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dshape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns list of categories corresponding to input shape"""</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"categories not implemented"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Validates input shape"""</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"validate not implemented"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Applies preprocessor to DataFrame and returns array"""</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"apply not implemented"</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">category_codes</span><span class="p">(</span><span class="n">CategoryPreprocess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Extract just the category codes from a categorical column.</span>

<span class="sd">    To create a new type of categorizer, derive a subclass from this</span>
<span class="sd">    class or one of its subclasses, implementing ``__init__``,</span>
<span class="sd">    ``_hashable_inputs``, ``categories``, ``validate``, and ``apply``.</span>

<span class="sd">    See the implementation of ``category_modulo`` in ``reductions.py``</span>
<span class="sd">    for an example.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">input_dshape</span><span class="o">.</span><span class="n">measure</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">categories</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_dshape</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"specified column not found"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_dshape</span><span class="o">.</span><span class="n">measure</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">],</span> <span class="n">ct</span><span class="o">.</span><span class="n">Categorical</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"input must be categorical"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cudf</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Version</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Version</span><span class="p">(</span><span class="s2">"22.02"</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">to_cupy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">to_gpu_array</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="o">.</span><span class="n">values</span>

<span class="k">class</span> <span class="nc">category_modulo</span><span class="p">(</span><span class="n">category_codes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    A variation on category_codes that assigns categories using an integer column, modulo a base.</span>
<span class="sd">    Category is computed as (column_value - offset)%modulo.</span>
<span class="sd">    """</span>

    <span class="c1"># couldn't find anything in the datashape docs about how to check if a CType is an integer, so</span>
    <span class="c1"># just define a big set</span>
    <span class="n">IntegerTypes</span> <span class="o">=</span> <span class="p">{</span><span class="n">ct</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span>
                    <span class="n">ct</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">int64</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">modulo</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modulo</span> <span class="o">=</span> <span class="n">modulo</span>

    <span class="k">def</span> <span class="nf">_hashable_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">modulo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modulo</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_dshape</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"specified column not found"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">in_dshape</span><span class="o">.</span><span class="n">measure</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">IntegerTypes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"input must be an integer column"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">modulo</span>
        <span class="k">if</span> <span class="n">cudf</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Version</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Version</span><span class="p">(</span><span class="s2">"22.02"</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">to_cupy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">to_gpu_array</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span>

<span class="k">class</span> <span class="nc">category_binning</span><span class="p">(</span><span class="n">category_modulo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    A variation on category_codes that assigns categories by binning a continuous-valued column.</span>
<span class="sd">    The number of categories returned is always nbins+1.</span>
<span class="sd">    The last category (nbin) is for NaNs in the data column, as well as for values under/over the</span>
<span class="sd">    binned interval (when include_under or include_over is False).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column:   column to use</span>
<span class="sd">    lower:    lower bound of first bin</span>
<span class="sd">    upper:    upper bound of last bin</span>
<span class="sd">    nbins:     number of bins</span>
<span class="sd">    include_under: if True, values below bin 0 are assigned to category 0</span>
<span class="sd">    include_over:  if True, values above the last bin (nbins-1) are assigned to category nbin-1</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">include_under</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_over</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># +1 category for NaNs and clipped values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin0</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="n">nbins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_under</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">include_under</span> <span class="k">else</span> <span class="n">nbins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_over</span>  <span class="o">=</span> <span class="n">nbins</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">include_over</span> <span class="k">else</span> <span class="n">nbins</span>

    <span class="k">def</span> <span class="nf">_hashable_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_under</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_over</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_dshape</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"specified column not found"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cudf</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Version</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Version</span><span class="p">(</span><span class="s2">"22.02"</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">to_cupy</span><span class="p">(</span><span class="n">na_value</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">to_gpu_array</span><span class="p">(</span><span class="n">fillna</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">nan_values</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">nan_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">index_float</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">binsize</span>
        <span class="c1"># NaN values are corrected below, so set them to zero to avoid warnings when</span>
        <span class="c1"># converting from float to int.</span>
        <span class="n">index_float</span><span class="p">[</span><span class="n">nan_values</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index_float</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">index</span><span class="p">[</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_under</span>
        <span class="n">index</span><span class="p">[</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_over</span>
        <span class="n">index</span><span class="p">[</span><span class="n">nan_values</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
        <span class="k">return</span> <span class="n">index</span>


<span class="k">class</span> <span class="nc">category_values</span><span class="p">(</span><span class="n">CategoryPreprocess</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Extract a category and a value column from a dataframe as (2,N) numpy array of values."""</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">categorizer</span><span class="p">,</span> <span class="n">value_column</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">value_column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span> <span class="o">=</span> <span class="n">categorizer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cat_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Returns name of categorized column"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">column</span>

    <span class="k">def</span> <span class="nf">categories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">categories</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">in_dshape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cudf</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">cupy</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
                <span class="n">nullval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">'f'</span><span class="p">:</span>
                <span class="n">nullval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nullval</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">Version</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Version</span><span class="p">(</span><span class="s2">"22.02"</span><span class="p">):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">to_cupy</span><span class="p">(</span><span class="n">na_value</span><span class="o">=</span><span class="n">nullval</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">cupy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">nullval</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">cupy</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cuda</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Reduction</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Base class for per-bin reductions."""</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">SpecialColumn</span> <span class="o">|</span> <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nan_check_column</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nan_check_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nan_check_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nan_check_column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Return ``True`` if this Reduction needs to use a CUDA mutex to</span>
<span class="sd">        ensure that it is threadsafe across CUDA threads.</span>

<span class="sd">        If the CUDA append functions are all atomic (i.e. using functions from</span>
<span class="sd">        the numba.cuda.atomic module) then this is ``False``, otherwise it is</span>
<span class="sd">        ``True``.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">No</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Return ``True`` if this Reduction uses a row index virtual column.</span>

<span class="sd">        For some reductions the order of the rows of supplied data is</span>
<span class="sd">        important. These include ``first`` and ``last`` reductions as well as</span>
<span class="sd">        ``where`` reductions that return a row index. In some situations the</span>
<span class="sd">        order is intrinsic such as ``first`` reductions that are processed</span>
<span class="sd">        sequentially (i.e. on a CPU without using Dask) and no extra column is</span>
<span class="sd">        required. But in situations of parallel processing (using a GPU or</span>
<span class="sd">        Dask) extra information is needed that is provided by a row index</span>
<span class="sd">        virtual column.</span>

<span class="sd">        Returning ``True`` from this function will cause a row index column to</span>
<span class="sd">        be created and passed to the ``append`` functions in the usual manner.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_dshape</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"specified column not found"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">in_dshape</span><span class="o">.</span><span class="n">measure</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"input must be numeric"</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">extract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Return ``True`` if this is or contains a categorical reduction."""</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_where</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Return ``True`` if this is a ``where`` reduction or directly wraps</span>
<span class="sd">        a where reduction."""</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return True if this Reduction must be processed with 2 stages,</span>
        <span class="c1"># False if it doesn't matter.</span>
        <span class="c1"># Overridden in derived classes as appropriate.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="c1"># Only called if using antialiased lines. Overridden in derived classes.</span>
        <span class="c1"># Returns a tuple containing an item for each constituent reduction.</span>
        <span class="c1"># Each item is (AntialiasCombination, zero_value)).</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">._antialias_stage_2 is not defined"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">_build_combine_temps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="c1"># Temporaries (i.e. not returned to user) that are reductions, the</span>
        <span class="c1"># aggs of which are passed to the combine() function but not the</span>
        <span class="c1"># append() functions, as opposed to _build_temps() which are passed</span>
        <span class="c1"># to both append() and combine().</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_temps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Temporaries (i.e. not returned to user) that are reductions, the</span>
        <span class="c1"># aggs of which are passed to both append() and combine() functions.</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">required_dshape</span><span class="o">.</span><span class="n">measure</span><span class="p">,</span> <span class="s2">"fields"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_dshape</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If more than one field then they all have the same dtype so can just take the first.</span>
            <span class="n">first_field</span> <span class="o">=</span> <span class="n">required_dshape</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">required_dshape</span> <span class="o">=</span> <span class="n">dshape</span><span class="p">(</span><span class="n">first_field</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">required_dshape</span><span class="p">,</span> <span class="n">Option</span><span class="p">):</span>
            <span class="n">required_dshape</span> <span class="o">=</span> <span class="n">dshape</span><span class="p">(</span><span class="n">required_dshape</span><span class="o">.</span><span class="n">ty</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">required_dshape</span> <span class="o">==</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_bool</span>
        <span class="k">elif</span> <span class="n">required_dshape</span> <span class="o">==</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_float32_nan</span>
        <span class="k">elif</span> <span class="n">required_dshape</span> <span class="o">==</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_float64_nan</span>
        <span class="k">elif</span> <span class="n">required_dshape</span> <span class="o">==</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_int64</span>
        <span class="k">elif</span> <span class="n">required_dshape</span> <span class="o">==</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">uint32</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_uint32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Unexpected dshape </span><span class="si">{</span><span class="n">dshape</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">antialias</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field_antialias_cuda</span>
            <span class="k">elif</span> <span class="n">antialias</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias_cuda</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field_cuda</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">antialias</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field_antialias</span>
            <span class="k">elif</span> <span class="n">antialias</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>

    <span class="k">def</span> <span class="nf">_build_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_bool</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'bool'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_float32_nan</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'f4'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_float64_nan</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'f8'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_float64_empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'f8'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_float64_zero</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'f8'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_int64</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'i8'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_uint32</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">array_module</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'u4'</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OptionalFieldReduction</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Base class for things like ``count`` or ``any`` for which the field is optional"""</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">extract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">in_dshape</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SelfIntersectingOptionalFieldReduction</span><span class="p">(</span><span class="n">OptionalFieldReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Base class for optional field reductions for which self-intersecting</span>
<span class="sd">    geometry may or may not be desirable.</span>
<span class="sd">    Ignored if not using antialiasing.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">self_intersect</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">self_intersect</span> <span class="o">=</span> <span class="n">self_intersect</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_intersect</span>

    <span class="k">def</span> <span class="nf">_build_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">antialias</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self_intersect</span><span class="p">:</span>
            <span class="c1"># append functions specific to antialiased lines without self_intersect</span>
            <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field_antialias_cuda_not_self_intersect</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias_cuda_not_self_intersect</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field_antialias_not_self_intersect</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias_not_self_intersect</span>

        <span class="c1"># Fall back to base class implementation</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_append</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hashable_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Reductions with different self_intersect attributes much have different hashes otherwise</span>
        <span class="c1"># toolz.memoize will treat them as the same to give incorrect results.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self_intersect</span><span class="p">,)</span>


<div class="viewcode-block" id="count"><a class="viewcode-back" href="../../api.html#datashader.reductions.count">[docs]</a><span class="k">class</span> <span class="nc">count</span><span class="p">(</span><span class="n">SelfIntersectingOptionalFieldReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Count elements in each bin, returning the result as a uint32, or a</span>
<span class="sd">    float32 if using antialiasing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str, optional</span>
<span class="sd">        If provided, only counts elements in ``column`` that are not ``NaN``.</span>
<span class="sd">        Otherwise, counts every element.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="n">antialias</span> <span class="k">else</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">self_intersect</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_1AGG</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_2AGG</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa_factor</span> <span class="o">-</span> <span class="n">prev_aa_factor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">aa_factor</span> <span class="o">-</span> <span class="n">prev_aa_factor</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias_not_self_intersect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">aa_factor</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa_factor</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_no_field</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">):</span>
        <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_no_field_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa_factor</span> <span class="o">-</span> <span class="n">prev_aa_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">aa_factor</span> <span class="o">-</span> <span class="n">prev_aa_factor</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_no_field_antialias_not_self_intersect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">aa_factor</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa_factor</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_antialias_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">cuda_atomic_nanmax</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">or</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_no_field_antialias_cuda_not_self_intersect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">aa_factor</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">cuda_atomic_nanmax</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">aa_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">or</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">aa_factor</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">nb_cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_no_field_antialias_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">aa_factor</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">cuda_atomic_nanmax</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">aa_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">or</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">aa_factor</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_no_field_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">):</span>
        <span class="n">nb_cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">antialias</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_antialias</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">aggs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'u4'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_antialias</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="n">nansum_in_place</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">class</span> <span class="nc">_count_ignore_antialiasing</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Count reduction but ignores antialiasing. Used by mean reduction.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">self_intersect</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_1AGG</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_2AGG</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">and</span> <span class="n">prev_aa_factor</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias_not_self_intersect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">and</span> <span class="n">prev_aa_factor</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">class</span> <span class="nc">by</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Apply the provided reduction separately per category.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cats: str or CategoryPreprocess instance</span>
<span class="sd">        Name of column to aggregate over, or a categorizer object that returns categories.</span>
<span class="sd">        Resulting aggregate has an outer dimension axis along the categories present.</span>
<span class="sd">    reduction : Reduction</span>
<span class="sd">        Per-category reduction function.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat_column</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="n">count</span><span class="p">()):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># set basic categorizer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat_column</span><span class="p">,</span> <span class="n">CategoryPreprocess</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span> <span class="o">=</span> <span class="n">cat_column</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat_column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span> <span class="o">=</span> <span class="n">category_codes</span><span class="p">(</span><span class="n">cat_column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"first argument must be a column name or a CategoryPreprocess instance"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">column</span> <span class="c1"># for backwards compatibility with count_cat</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">column</span><span class="p">,)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">columns</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reduction</span><span class="p">,</span> <span class="s1">'columns'</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Must reverse columns (from where reduction) so that val_column property</span>
            <span class="c1"># is the column that is returned to the user.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">+=</span> <span class="n">columns</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">reduction</span><span class="p">,</span> <span class="s1">'column'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="n">reduction</span>
        <span class="c1"># if a value column is supplied, set category_values preprocessor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_column</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">category_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">(),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_build_temps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">by</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_temps</span><span class="p">(</span><span class="n">cuda</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cat_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">val_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">in_dshape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">in_dshape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">categories</span><span class="p">(</span><span class="n">input_dshape</span><span class="p">)</span>
        <span class="n">red_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">out_dshape</span><span class="p">(</span><span class="n">input_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">Record</span><span class="p">([(</span><span class="n">c</span><span class="p">,</span> <span class="n">red_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cats</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_where</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">is_where</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nan_check_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">nan_check_column</span>

    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">uses_cuda_mutex</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_antialias_requires_2_stages</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_antialias_stage_2</span><span class="p">(</span><span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">combination</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">combination</span><span class="p">,</span>
                                <span class="n">zero</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span>
                                <span class="n">n_reduction</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_reduction</span><span class="p">,</span>
                                <span class="n">categorical</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="n">n_cats</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">required_dshape</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_create</span><span class="p">(</span>
            <span class="n">required_dshape</span><span class="p">)(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_cats</span><span class="p">,),</span> <span class="n">array_module</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bases</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">by</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_append</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_combine</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_combine_temps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_combine_temps</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">):</span>
        <span class="n">cats</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categorizer</span><span class="o">.</span><span class="n">categories</span><span class="p">(</span><span class="n">dshape</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Return a modified copy of kwargs. Cannot modify supplied kwargs as it</span>
            <span class="c1"># may be used by multiple reductions, e.g. if a summary reduction.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'dims'</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_column</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'coords'</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">cats</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="o">.</span><span class="n">_build_finalize</span><span class="p">(</span><span class="n">dshape</span><span class="p">)(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">finalize</span>

<div class="viewcode-block" id="any"><a class="viewcode-back" href="../../api.html#datashader.reductions.any">[docs]</a><span class="k">class</span> <span class="nc">any</span><span class="p">(</span><span class="n">OptionalFieldReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Whether any elements in ``column`` map to each bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str, optional</span>
<span class="sd">        If provided, any elements in ``column`` that are ``NaN`` are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="n">antialias</span> <span class="k">else</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MAX</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">aa_factor</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa_factor</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_no_field</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">):</span>
        <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_no_field_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">aa_factor</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aa_factor</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="n">_append_cuda</span> <span class="o">=</span><span class="n">_append</span>
    <span class="n">_append_no_field_cuda</span> <span class="o">=</span> <span class="n">_append_no_field</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">antialias</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_antialias</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">aggs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'bool'</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_antialias</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="n">nanmax_in_place</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">class</span> <span class="nc">_upsample</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""""Special internal class used for upsampling"""</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">Option</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">extract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="c1"># Use uninitialized memory, the upsample function must explicitly set unused</span>
        <span class="c1"># values to nan</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_float64_empty</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># not called, the upsample function must set agg directly</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># not called, the upsample function must set agg directly</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FloatingReduction</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Base classes for reductions that always have floating-point dtype."""</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">Option</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_sum_zero</span><span class="p">(</span><span class="n">FloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Sum of all elements in ``column``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">self_intersect</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_1AGG</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_2AGG</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_float64_zero</span>

    <span class="c1"># CPU append functions.</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1"># agg[y, x] cannot be null as initialised to zero.</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="p">(</span><span class="n">aa_factor</span> <span class="o">-</span> <span class="n">prev_aa_factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># agg[y, x] cannot be null as initialised to zero.</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias_not_self_intersect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="c1"># agg[y, x] cannot be null as initialised to zero.</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">nb_cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">aggs</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'f8'</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SelfIntersectingFloatingReduction</span><span class="p">(</span><span class="n">FloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Base class for floating reductions for which self-intersecting geometry</span>
<span class="sd">    may or may not be desirable.</span>
<span class="sd">    Ignored if not using antialiasing.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">self_intersect</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">self_intersect</span> <span class="o">=</span> <span class="n">self_intersect</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_intersect</span>

    <span class="k">def</span> <span class="nf">_build_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">antialias</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">self_intersect</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"SelfIntersectingOptionalFieldReduction"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_no_field_antialias_not_self_intersect</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias_not_self_intersect</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_append</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hashable_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Reductions with different self_intersect attributes much have different hashes otherwise</span>
        <span class="c1"># toolz.memoize will treat them as the same to give incorrect results.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self_intersect</span><span class="p">,)</span>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../api.html#datashader.reductions.sum">[docs]</a><span class="k">class</span> <span class="nc">sum</span><span class="p">(</span><span class="n">SelfIntersectingFloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Sum of all elements in ``column``.</span>

<span class="sd">    Elements of resulting aggregate are nan if they are not updated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">self_intersect</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_1AGG</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">SUM_2AGG</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">_sum_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="p">(</span><span class="n">aa_factor</span> <span class="o">-</span> <span class="n">prev_aa_factor</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias_not_self_intersect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
                <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nansum_missing</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="n">sums</span><span class="p">,</span> <span class="n">anys</span> <span class="o">=</span> <span class="n">bases</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">anys</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="m2"><a class="viewcode-back" href="../../api.html#datashader.reductions.m2">[docs]</a><span class="k">class</span> <span class="nc">m2</span><span class="p">(</span><span class="n">FloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Sum of square differences from the mean of all elements in ``column``.</span>

<span class="sd">    Intermediate value for computing ``var`` and ``std``, not intended to be</span>
<span class="sd">    used on its own.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">Global</span>

    <span class="k">def</span> <span class="nf">_build_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_build_append</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_float64_zero</span>

    <span class="k">def</span> <span class="nf">_build_temps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_sum_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="c1"># sum &amp; count are the results of sum[y, x], count[y, x] before being</span>
        <span class="c1"># updated by field</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="n">field</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">m2</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">field</span> <span class="o">-</span> <span class="n">u1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">field</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="c1"># sum &amp; count are the results of sum[y, x], count[y, x] before being</span>
        <span class="c1"># updated by field</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="nb">sum</span> <span class="o">+</span> <span class="n">field</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">m2</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">field</span> <span class="o">-</span> <span class="n">u1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">field</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">Ms</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">sums</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">ns</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Ms</span> <span class="o">+</span> <span class="n">ns</span><span class="o">*</span><span class="p">(</span><span class="n">sums</span><span class="o">/</span><span class="n">ns</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../api.html#datashader.reductions.min">[docs]</a><span class="k">class</span> <span class="nc">min</span><span class="p">(</span><span class="n">FloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Minimum value of all elements in ``column``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MIN</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">field</span><span class="p">):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">cuda_atomic_nanmin</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">or</span> <span class="n">old</span> <span class="o">&gt;</span> <span class="n">field</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../api.html#datashader.reductions.max">[docs]</a><span class="k">class</span> <span class="nc">max</span><span class="p">(</span><span class="n">FloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Maximum value of all elements in ``column``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MAX</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">field</span><span class="p">):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_antialias_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">cuda_atomic_nanmax</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">or</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">cuda_atomic_nanmax</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">or</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">field</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="count_cat"><a class="viewcode-back" href="../../api.html#datashader.reductions.count_cat">[docs]</a><span class="k">class</span> <span class="nc">count_cat</span><span class="p">(</span><span class="n">by</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Count of all elements in ``column``, grouped by category.</span>
<span class="sd">    Alias for `by(...,count())`, for backwards compatibility.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be</span>
<span class="sd">        categorical. Resulting aggregate has a outer dimension axis along the</span>
<span class="sd">        categories present.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">count_cat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">count</span><span class="p">())</span></div>


<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../api.html#datashader.reductions.mean">[docs]</a><span class="k">class</span> <span class="nc">mean</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Mean of all elements in ``column``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_sum_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">_count_ignore_antialiasing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sums</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">bases</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sums</span><span class="o">/</span><span class="n">counts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../api.html#datashader.reductions.var">[docs]</a><span class="k">class</span> <span class="nc">var</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Variance of all elements in ``column``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_sum_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">m2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sums</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">m2s</span> <span class="o">=</span> <span class="n">bases</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m2s</span> <span class="o">/</span> <span class="n">counts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../api.html#datashader.reductions.std">[docs]</a><span class="k">class</span> <span class="nc">std</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Standard Deviation of all elements in ``column``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. Column data type must be numeric.</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_sum_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">m2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sums</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">m2s</span> <span class="o">=</span> <span class="n">bases</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m2s</span> <span class="o">/</span> <span class="n">counts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">_first_or_last</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Abstract base class of first and last reductions.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cuda</span> <span class="ow">or</span> <span class="n">partitioned</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
            <span class="n">row_index_selector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_row_index_selector</span><span class="p">()</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">selector</span><span class="o">=</span><span class="n">row_index_selector</span><span class="p">,</span> <span class="n">lookup_column</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">_nan_check_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
            <span class="c1"># where reduction is always preceded by its selector reduction</span>
            <span class="k">return</span> <span class="n">row_index_selector</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">wrapper</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="c1"># Dask combine is handled by a where reduction using a row index.</span>
        <span class="c1"># Hence this can only ever be called if npartitions == 1 in which case len(aggs) == 1.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"_combine should never be called with more than one agg"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_create_row_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Note returning the last of the bases which is correct regardless of whether</span>
        <span class="c1"># this is a simple reduction (with a single base) or a compound where reduction</span>
        <span class="c1"># (with 2 bases, the second of which is the where reduction).</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="first"><a class="viewcode-back" href="../../api.html#datashader.reductions.first">[docs]</a><span class="k">class</span> <span class="nc">first</span><span class="p">(</span><span class="n">_first_or_last</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""First value encountered in ``column``.</span>

<span class="sd">    Useful for categorical data where an actual value must always be returned,</span>
<span class="sd">    not an average or other numerical calculation.</span>

<span class="sd">    Currently only supported for rasters, externally to this class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. If the data type is floating point,</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">FIRST</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_create_row_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_min_row_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="last"><a class="viewcode-back" href="../../api.html#datashader.reductions.last">[docs]</a><span class="k">class</span> <span class="nc">last</span><span class="p">(</span><span class="n">_first_or_last</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Last value encountered in ``column``.</span>

<span class="sd">    Useful for categorical data where an actual value must always be returned,</span>
<span class="sd">    not an average or other numerical calculation.</span>

<span class="sd">    Currently only supported for rasters, externally to this class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. If the data type is floating point,</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">LAST</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_create_row_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_max_row_index</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">FloatingNReduction</span><span class="p">(</span><span class="n">OptionalFieldReduction</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_finalize_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Add the new dimension and coordinate.</span>
        <span class="n">n_name</span> <span class="o">=</span> <span class="s2">"n"</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># Return a modified copy of kwargs. Cannot modify supplied kwargs as it</span>
        <span class="c1"># may be used by multiple reductions, e.g. if a summary reduction.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'dims'</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n_name</span><span class="p">]</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'coords'</span><span class="p">][</span><span class="n">n_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_values</span>
        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">:</span> <span class="nb">super</span><span class="p">(</span><span class="n">FloatingNReduction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_build_create</span><span class="p">(</span>
            <span class="n">required_dshape</span><span class="p">)(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,),</span> <span class="n">array_module</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_finalize_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="n">cuda</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">finalize</span>

    <span class="k">def</span> <span class="nf">_hashable_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,)</span>


<span class="k">class</span> <span class="nc">_first_n_or_last_n</span><span class="p">(</span><span class="n">FloatingNReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Abstract base class of first_n and last_n reductions.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cuda</span> <span class="ow">or</span> <span class="n">partitioned</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
            <span class="n">row_index_selector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_row_index_selector</span><span class="p">()</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">selector</span><span class="o">=</span><span class="n">row_index_selector</span><span class="p">,</span> <span class="n">lookup_column</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">_nan_check_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
            <span class="c1"># where reduction is always preceded by its selector reduction</span>
            <span class="k">return</span> <span class="n">row_index_selector</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">wrapper</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="c1"># Dask combine is handled by a where reduction using a row index.</span>
        <span class="c1"># Hence this can only ever be called if npartitions == 1 in which case len(aggs) == 1.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"_combine should never be called with more than one agg"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_create_row_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Note returning the last of the bases which is correct regardless of whether</span>
        <span class="c1"># this is a simple reduction (with a single base) or a compound where reduction</span>
        <span class="c1"># (with 2 bases, the second of which is the where reduction).</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">first_n</span><span class="p">(</span><span class="n">_first_n_or_last_n</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">FIRST</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_reduction</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1"># Check final value first for quick abort.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                    <span class="c1">#Â Nothing to shift.</span>
                    <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># Check final value first for quick abort.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]):</span>
                    <span class="c1">#Â Nothing to shift.</span>
                    <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_create_row_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_min_n_row_index</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">last_n</span><span class="p">(</span><span class="n">_first_n_or_last_n</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">LAST</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_reduction</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1">#Â Always inserts at front of agg's third dimension.</span>
            <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1">#Â Always inserts at front of agg's third dimension.</span>
            <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_create_row_index_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_max_n_row_index</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">max_n</span><span class="p">(</span><span class="n">FloatingNReduction</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">Local</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MAX</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_reduction</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">nanmax_n_in_place_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nanmax_n_in_place_4d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_cuda</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kernel_args</span> <span class="o">=</span> <span class="n">cuda_args</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">cuda_nanmax_n_in_place_3d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cuda_nanmax_n_in_place_4d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">min_n</span><span class="p">(</span><span class="n">FloatingNReduction</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">Local</span>

    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MIN</span><span class="p">,</span> <span class="n">array_module</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">n_reduction</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">*</span><span class="n">aa_factor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isnull</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isnull</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">nanmin_n_in_place_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nanmin_n_in_place_4d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_cuda</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kernel_args</span> <span class="o">=</span> <span class="n">cuda_args</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">cuda_nanmin_n_in_place_3d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cuda_nanmin_n_in_place_4d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="mode"><a class="viewcode-back" href="../../api.html#datashader.reductions.mode">[docs]</a><span class="k">class</span> <span class="nc">mode</span><span class="p">(</span><span class="n">Reduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Mode (most common value) of all the values encountered in ``column``.</span>

<span class="sd">    Useful for categorical data where an actual value must always be returned,</span>
<span class="sd">    not an average or other numerical calculation.</span>

<span class="sd">    Currently only supported for rasters, externally to this class.</span>
<span class="sd">    Implementing it for other glyph types would be difficult due to potentially</span>
<span class="sd">    unbounded data storage requirements to store indefinite point or line</span>
<span class="sd">    data per pixel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    column : str</span>
<span class="sd">        Name of the column to aggregate over. If the data type is floating point,</span>
<span class="sd">        ``NaN`` values in the column are skipped.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">Option</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"mode is currently implemented only for rasters"</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"mode is currently implemented only for rasters"</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"mode is currently implemented only for rasters"</span><span class="p">)</span></div>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../api.html#datashader.reductions.where">[docs]</a><span class="k">class</span> <span class="nc">where</span><span class="p">(</span><span class="n">FloatingReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Returns values from a ``lookup_column`` corresponding to a ``selector``</span>
<span class="sd">    reduction that is applied to some other column.</span>

<span class="sd">    If ``lookup_column`` is ``None`` then it uses the index of the row in the</span>
<span class="sd">    DataFrame instead of a named column. This is returned as an int64</span>
<span class="sd">    aggregation with -1 used to denote no value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; canvas.line(df, 'x', 'y', agg=ds.where(ds.max("value"), "other"))  # doctest: +SKIP</span>

<span class="sd">    This returns the values of the "other" column that correspond to the</span>
<span class="sd">    maximum of the "value" column in each bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    selector: Reduction</span>
<span class="sd">        Reduction used to select the values of the ``lookup_column`` which are</span>
<span class="sd">        returned by this ``where`` reduction.</span>

<span class="sd">    lookup_column : str | None</span>
<span class="sd">        Column containing values that are returned from this ``where``</span>
<span class="sd">        reduction, or ``None`` to return row indexes instead.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="n">Reduction</span><span class="p">,</span> <span class="n">lookup_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">first_n</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">last_n</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="n">min_n</span><span class="p">,</span>
                                     <span class="n">_max_or_min_row_index</span><span class="p">,</span> <span class="n">_max_n_or_min_n_row_index</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">"selector can only be a first, first_n, last, last_n, "</span>
                <span class="s2">"max, max_n, min or min_n reduction"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lookup_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lookup_column</span> <span class="o">=</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lookup_column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">selector</span>
        <span class="c1"># List of all column names that this reduction uses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">(</span><span class="n">selector</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="n">lookup_column</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_inputs</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">is_where</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">Local</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">!=</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">in_dshape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">in_dshape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">!=</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">column</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"where and its contained reduction cannot use the same column"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">_antialias_stage_2</span><span class="p">(</span><span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
            <span class="c1"># Override antialiased zero value when returning integer row index.</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">combination</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">combination</span><span class="p">,</span>
                                   <span class="n">zero</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                   <span class="n">n_reduction</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_reduction</span><span class="p">),)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="c1"># CPU append functions</span>
    <span class="c1">#Â All where._append* functions have an extra argument which is the update index.</span>
    <span class="c1"># For 3D aggs like max_n, this is the index of insertion in the final dimension,</span>
    <span class="c1"># and the previous values from this index upwards are shifted along to make room</span>
    <span class="c1"># for the new value.</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">update_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">update_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
        <span class="k">return</span> <span class="n">update_index</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">,</span> <span class="n">update_index</span><span class="p">):</span>
        <span class="c1"># Ignore aa_factor.</span>
        <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">update_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_antialias_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">,</span> <span class="n">update_index</span><span class="p">):</span>
        <span class="c1"># Ignore aa_factor</span>
        <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">update_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
        <span class="k">return</span> <span class="n">update_index</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">update_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">agg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">update_index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
        <span class="k">return</span> <span class="n">update_index</span>

    <span class="k">def</span> <span class="nf">_build_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">):</span>
        <span class="c1"># If self.column is SpecialColumn.RowIndex then append function is passed a</span>
        <span class="c1"># 'field' argument which is the row index.</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">antialias</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias_cuda</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">antialias</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_antialias</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append</span>

    <span class="k">def</span> <span class="nf">_build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="n">selector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="p">(</span><span class="n">_first_or_last</span><span class="p">,</span> <span class="n">_first_n_or_last_n</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="n">selector</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
            <span class="c1"># Need to swap out the selector with an equivalent row index selector</span>
            <span class="n">row_index_selector</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">_create_row_index_selector</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">==</span> <span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">:</span>
                <span class="c1"># If selector uses a row index and this where returns the same row index,</span>
                <span class="c1"># can just swap out this where reduction with the row_index_selector.</span>
                <span class="n">row_index_selector</span><span class="o">.</span><span class="n">_nan_check_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">column</span>
                <span class="k">return</span> <span class="n">row_index_selector</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_where</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">row_index_selector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
                <span class="n">new_where</span><span class="o">.</span><span class="n">_nan_check_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">column</span>
                <span class="k">return</span> <span class="n">row_index_selector</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="n">new_where</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">selector</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span> <span class="o">+</span> \
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_bases</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span><span class="p">):</span>
        <span class="c1">#Â Used by:</span>
        <span class="c1"># 1) where._build_combine()) below, the usual mechanism for combining aggs from</span>
        <span class="c1">#    different dask partitions.</span>
        <span class="c1"># 2) make_antialias_stage_2_functions() in compiler.py to perform stage 2 combine</span>
        <span class="c1">#    of antialiased aggs.</span>
        <span class="n">selector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span>
        <span class="n">is_n_reduction</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="n">FloatingNReduction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="n">append</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">_append_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">append</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">_append</span>

        <span class="c1"># If the selector uses a row_index then selector_aggs will be int64 with -1</span>
        <span class="c1"># representing missing data. Otherwise missing data is NaN.</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="n">isminus1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">)</span> <span class="k">else</span> <span class="n">isnull</span>

        <span class="nd">@ngjit</span>
        <span class="k">def</span> <span class="nf">combine_cpu_2d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

        <span class="nd">@ngjit</span>
        <span class="k">def</span> <span class="nf">combine_cpu_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ncat</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncat</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">cat</span><span class="p">],</span>
                                                         <span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span>

        <span class="nd">@ngjit</span>
        <span class="k">def</span> <span class="nf">combine_cpu_n_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">update_index</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">update_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">update_index</span><span class="p">)</span>

        <span class="nd">@ngjit</span>
        <span class="k">def</span> <span class="nf">combine_cpu_n_4d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ncat</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncat</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                                <span class="k">break</span>
                            <span class="n">update_index</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">cat</span><span class="p">,</span> <span class="p">:],</span> <span class="n">value</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">update_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">break</span>
                            <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                             <span class="n">update_index</span><span class="p">)</span>

        <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span>
        <span class="k">def</span> <span class="nf">combine_cuda_2d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nb_cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

        <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span>
        <span class="k">def</span> <span class="nf">combine_cuda_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ncat</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">nb_cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ny</span> <span class="ow">and</span> <span class="n">cat</span> <span class="o">&lt;</span> <span class="n">ncat</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">cat</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span>

        <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span>
        <span class="k">def</span> <span class="nf">combine_cuda_n_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nb_cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="n">update_index</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">update_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">update_index</span><span class="p">)</span>

        <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span>
        <span class="k">def</span> <span class="nf">combine_cuda_n_4d</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ncat</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">nb_cuda</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">nx</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ny</span> <span class="ow">and</span> <span class="n">cat</span> <span class="o">&lt;</span> <span class="n">ncat</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">invalid</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="n">update_index</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">cat</span><span class="p">,</span> <span class="p">:],</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">update_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">update_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_n_reduction</span><span class="p">:</span>
            <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
            <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">combine_cuda_n_4d</span> <span class="k">if</span> <span class="n">categorical</span> <span class="k">else</span> <span class="n">combine_cuda_n_3d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">combine_cpu_n_4d</span> <span class="k">if</span> <span class="n">categorical</span> <span class="k">else</span> <span class="n">combine_cpu_n_3d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Â ndim is either 2 (ny, nx) or 3 (ny, nx, ncat)</span>
            <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">combine_cuda_3d</span> <span class="k">if</span> <span class="n">categorical</span> <span class="k">else</span> <span class="n">combine_cuda_2d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">combine_cpu_3d</span> <span class="k">if</span> <span class="n">categorical</span> <span class="k">else</span> <span class="n">combine_cpu_2d</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">combine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_callback</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">wrapped_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">cuda</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">is_n_reduction</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">,</span> <span class="n">FloatingNReduction</span><span class="p">)</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_n_reduction</span> <span class="k">else</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">combine</span><span class="p">[</span><span class="n">cuda_args</span><span class="p">(</span><span class="n">shape</span><span class="p">)](</span><span class="n">aggs</span><span class="p">,</span> <span class="n">selector_aggs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
                    <span class="n">combine</span><span class="p">((</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="p">(</span><span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="k">return</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">selector_aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">wrapped_combine</span>

    <span class="k">def</span> <span class="nf">_build_combine_temps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">_build_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">required_dshape</span><span class="p">):</span>
        <span class="c1"># Return a function that when called with a shape creates an agg array</span>
        <span class="c1"># of the required type (numpy/cupy) and dtype.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">,</span> <span class="n">FloatingNReduction</span><span class="p">):</span>
            <span class="c1"># This specialisation isn't ideal but Reduction classes do not</span>
            <span class="c1"># store information about the required extra dimension.</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">shape</span><span class="p">,</span> <span class="n">array_module</span><span class="p">:</span> <span class="nb">super</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_build_create</span><span class="p">(</span>
                <span class="n">required_dshape</span><span class="p">)(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">n</span><span class="p">,),</span> <span class="n">array_module</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_build_create</span><span class="p">(</span><span class="n">required_dshape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">,</span> <span class="n">FloatingNReduction</span><span class="p">):</span>
            <span class="n">add_finalize_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">_add_finalize_kwargs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_finalize_kwargs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">add_finalize_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">add_finalize_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">finalize</span></div>


<div class="viewcode-block" id="summary"><a class="viewcode-back" href="../../api.html#datashader.reductions.summary">[docs]</a><span class="k">class</span> <span class="nc">summary</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""A collection of named reductions.</span>

<span class="sd">    Computes all aggregates simultaneously, output is stored as a</span>
<span class="sd">    ``xarray.Dataset``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A reduction for computing the mean of column "a", and the sum of column "b"</span>
<span class="sd">    for each bin, all in a single pass.</span>

<span class="sd">    &gt;&gt;&gt; import datashader as ds</span>
<span class="sd">    &gt;&gt;&gt; red = ds.summary(mean_a=ds.mean('a'), sum_b=ds.sum('b'))</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A single pass of the source dataset using antialiased lines can either be</span>
<span class="sd">    performed using a single-stage aggregation (e.g. ``self_intersect=True``)</span>
<span class="sd">    or two stages (``self_intersect=False``). If a ``summary`` contains a</span>
<span class="sd">    ``count`` or ``sum`` reduction with ``self_intersect=False``, or any of</span>
<span class="sd">    ``first``, ``last`` or ``min``, then the antialiased line pass will be</span>
<span class="sd">    performed in two stages.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ks</span><span class="p">,</span> <span class="n">vs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="n">ks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">vs</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_categorical</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">uses_row_index</span><span class="p">(</span><span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dshape</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="n">v</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">input_dshape</span><span class="p">)</span>

        <span class="c1"># Check that any included FloatingNReductions have the same n values.</span>
        <span class="n">n_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">selector</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">FloatingNReduction</span><span class="p">):</span>
                <span class="n">n_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">n_values</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"Using multiple FloatingNReductions with different n values is not supported"</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">concat</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">inputs</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)))</span></div>


<span class="k">class</span> <span class="nc">_max_or_min_row_index</span><span class="p">(</span><span class="n">OptionalFieldReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Abstract base class of max and min row_index reductions.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_max_row_index</span><span class="p">(</span><span class="n">_max_or_min_row_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Max reduction operating on row index.</span>

<span class="sd">    This is a private class as it is not intended to be used explicitly in</span>
<span class="sd">    user code. It is primarily purpose is to support the use of ``last``</span>
<span class="sd">    reductions using dask and/or CUDA.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1">#Â field is int64 row index</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="c1">#Â field is int64 row index</span>
        <span class="c1"># Ignore aa_factor</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1">#Â field is int64 row index</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">nb_cuda</span><span class="o">.</span><span class="n">atomic</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old</span> <span class="o">&lt;</span> <span class="n">field</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="c1"># Maximum ignoring -1 values</span>
        <span class="c1"># Works for CPU and GPU</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="c1"># Works with numpy or cupy arrays</span>
            <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">_min_row_index</span><span class="p">(</span><span class="n">_max_or_min_row_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Min reduction operating on row index.</span>

<span class="sd">    This is a private class as it is not intended to be used explicitly in</span>
<span class="sd">    user code. It is primarily purpose is to support the use of ``first``</span>
<span class="sd">    reductions using dask and/or CUDA.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span>

    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">Local</span>

    <span class="c1"># CPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="c1"># Ignore aa_factor</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="c1"># Always uses cuda mutex so this does not need to be atomic</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
            <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="c1"># Minimum ignoring -1 values</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
            <span class="c1"># Can take 2d (ny, nx) or 3d (ny, nx, ncat) arrays.</span>
            <span class="n">row_min_in_place</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_cuda</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1">#Â ndim is either 2 (ny, nx) or 3 (ny, nx, ncat)</span>
                <span class="c1"># 3d view of each agg</span>
                <span class="n">aggs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">agg</span> <span class="ow">in</span> <span class="n">aggs</span><span class="p">]</span>
            <span class="n">kernel_args</span> <span class="o">=</span> <span class="n">cuda_args</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)):</span>
                <span class="n">cuda_row_min_in_place</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">_max_n_or_min_n_row_index</span><span class="p">(</span><span class="n">FloatingNReduction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Abstract base class of max_n and min_n row_index reductions.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="n">SpecialColumn</span><span class="o">.</span><span class="n">RowIndex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">out_dshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dshape</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">uses_cuda_mutex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UsesCudaMutex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UsesCudaMutex</span><span class="o">.</span><span class="n">Local</span>

    <span class="k">def</span> <span class="nf">uses_row_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_build_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dshape</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">partitioned</span><span class="p">,</span> <span class="n">categorical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_cuda</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span>


<span class="k">class</span> <span class="nc">_max_n_row_index</span><span class="p">(</span><span class="n">_max_n_or_min_n_row_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Max_n reduction operating on row index.</span>

<span class="sd">    This is a private class as it is not intended to be used explicitly in</span>
<span class="sd">    user code. It is primarily purpose is to support the use of ``last_n``</span>
<span class="sd">    reductions using dask and/or CUDA.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_reduction</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="c1"># Ignoring aa_factor</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># Bump previous values along to make room for new value.</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># GPU append functions</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1">#Â field is int64 row index</span>
        <span class="c1"># Always uses cuda mutex so this does not need to be atomic</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&gt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">row_max_n_in_place_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row_max_n_in_place_4d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_cuda</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kernel_args</span> <span class="o">=</span> <span class="n">cuda_args</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">cuda_row_max_n_in_place_3d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cuda_row_max_n_in_place_4d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">_min_n_row_index</span><span class="p">(</span><span class="n">_max_n_or_min_n_row_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Min_n reduction operating on row index.</span>

<span class="sd">    This is a private class as it is not intended to be used explicitly in</span>
<span class="sd">    user code. It is primarily purpose is to support the use of ``first_n``</span>
<span class="sd">    reductions using dask and/or CUDA.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_antialias_requires_2_stages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_antialias_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">self_intersect</span><span class="p">,</span> <span class="n">array_module</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AntialiasStage2</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">AntialiasStage2</span><span class="p">(</span><span class="n">AntialiasCombination</span><span class="o">.</span><span class="n">MIN</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_reduction</span><span class="o">=</span><span class="kc">True</span><span class="p">),)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@ngjit</span>
    <span class="k">def</span> <span class="nf">_append_antialias</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">aa_factor</span><span class="p">,</span> <span class="n">prev_aa_factor</span><span class="p">):</span>
        <span class="c1"># field is int64 row index</span>
        <span class="c1"># Ignoring aa_factor</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@nb_cuda</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_append_cuda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">agg</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="c1">#Â field is int64 row index</span>
        <span class="c1"># Always uses cuda mutex so this does not need to be atomic</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Linear walk along stored values.</span>
            <span class="c1"># Could do binary search instead but not expecting n to be large.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                    <span class="n">cuda_shift_and_insert</span><span class="p">(</span><span class="n">agg</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">row_min_n_in_place_3d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row_min_n_in_place_4d</span><span class="p">(</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_cuda</span><span class="p">(</span><span class="n">aggs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kernel_args</span> <span class="o">=</span> <span class="n">cuda_args</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1">#Â ndim is either 3 (ny, nx, n) or 4 (ny, nx, ncat, n)</span>
                <span class="n">cuda_row_min_n_in_place_3d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cuda_row_min_n_in_place_4d</span><span class="p">[</span><span class="n">kernel_args</span><span class="p">](</span><span class="n">aggs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">aggs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ret</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span><span class="n">_v</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span><span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span><span class="n">Reduction</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_v</span> <span class="ow">is</span> <span class="n">summary</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">_v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Reduction</span><span class="p">,</span> <span class="n">OptionalFieldReduction</span><span class="p">,</span>
                                   <span class="n">FloatingReduction</span><span class="p">,</span> <span class="n">m2</span><span class="p">]]))</span> <span class="o">+</span> \
                    <span class="p">[</span><span class="s1">'category_modulo'</span><span class="p">,</span> <span class="s1">'category_binning'</span><span class="p">]</span>
</pre></div>
</article>
<footer class="bd-footer-article">
<div class="footer-article-items footer-article__inner">
<div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
</div>
</footer>
</div>
</div>
<footer class="bd-footer-content">
</footer>
</main>
</div>
</div>
<!-- Scripts loaded after <body> so the DOM is not blocked -->
<script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>
<footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
<div class="footer-items__start">
<div class="footer-item"><p class="nbsite-copyright-last-updated">
<span class="copyright">
            Â© Copyright 2016-2023 Holoviz contributors.
    </span>
<span class="last-updated">Last updated on 2023-10-31.</span><br/>
</p></div>
</div>
<div class="footer-items__end">
<div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
</div>
</div>
</footer>
</body>
</html>